[{"content":"For this module we had to network a game using any networking API. During the classes we were taught winsock and SFML. For my coursework I decided to use my year 1 asteroids game as a base and add networking using SFML on top.\nThe Network Architecture I chose for the projcet was Server-Client. Reasoning being that it scales easier than P2P. It is more secure, because the Server has to verify the data from the players and more stable if a Client crashes, thus not affecting the other Clients if the host-client crashes by mistake in P2P. Server can currently handle up to 4 clients, but the game is limited to 2 sprites to make testing faster.\nFor the Transport layer protocols I chose TCP for handling the player Lives, The total Score, each client\u0026rsquo;s ID and the game Time. Those are things which I do not want to lose track of in case of Packet drops. For the player positions, rotation and packet sent time I used UDP. A packet not arriving containing that data does not impact the game there is\ninterpolation for the player positions.\nApplication layer Protocols Client (every packet is cleared after being received/sent):  Receives TCP Init packet on first connection with the server containing int values for Life/Score/ClientID Receives TCP packet containing Lives/Score/Server GameTime Receives UDP Packet containing player position/rotation/time when other client sent packet and pushes them into separate vectors for later use with interpolation Sends UDP packet every 1/3s containing player position/rotation/Client game time Sends TCP packet every 1/3s containing Lives and Score  Server (every packet is cleared after being received/sent):  Establishes a Listener and a vector of sf::TcpSocket* On first connection with client accept *socket and add socket to vector If new client sends TCP Init packet containing int values for Life/Score/ClientID On existing TCP clients sends packet containing Lives/Score/Server GameTime every 1/3s On existing UDP clients receive packet containing player position/rotation variables (floats) and a float containing when the client sent the packet On UDP receive add the Port of the sender into an std::set On UDP send go through std::set of ports and send packet to everyone but the original sender  Network Code Structure:  Non-blocking sockets for TCP and UDP past the initial connection Server.exe handles both TCP and UDP communication and clients   TCP communication is handled through a vector containing all connected client sockets     UDP communication is handled through an std::set containing all the ports the server has received a UDP packet from   Client.exe handles sending and receiving information given to it by the server  Lessons Learned  Newfound appreciation for network programmers Need to work on my network architecture skills Need to start from a better organised game and work up. Handling multiple clients can cause time desync between clients - need a very good time handling method/architecture A lot about timing and clocks in games (which was also the origin of the majority of the issues I had)  ","description":"First Networking Application I made, used the Asteroids game as a base","id":0,"section":"posts","tags":["sfml","networking","cpp"],"title":"Networking with Asteroids","uri":"https://devpilgrim.com/posts/asteroids_networked/"},{"content":"Hello and welcome back In this post I will go over how I\u0026rsquo;ve implemented object pooling into a simple game I made in Unity. I have been wanting to write this for a while, but I was on holiday and then had to catch up on work and did not have the time to do so. So without further adieu let\u0026rsquo;s dive in.\nLet\u0026rsquo;s start with understanding what an object pool is. For example in the case of Unity whenever you want to create an enemy ship you call Instantiate() and when you want to destroy it you call Destroy(). Those are helpful functions during gameplay and used quite often, they also generally require minimal CPU time.\nHowever, for objects created during gameplay that have a short lifespan and get destroyed in vast numbers per second, the CPU needs to allocate considerably more time. A great example for that is bullets. They are often on the screen for a fraction of a second and there\u0026rsquo;s tens or hundreds of them at any given moment. Constantly having to call Instantiate() and Destroy() can get quite resource intensive. Also repeatedly calling Destroy() frequently trigger Unity\u0026rsquo;s Garbage Collector which further slows down the CPU and may introduce pauses to gameplay.\nObject pooling is where you pre-instantiate all the objects you’ll need at any specific moment before gameplay — for instance, during a loading screen. Instead of creating new objects and destroying old ones during gameplay, your game reuses objects from a “pool”.\nAnother option, tho simpler, is to load all the game objects you wish to use off-screen in an array and disable their logic. When you want to spawn an enemy just take the first disabled enemy and position him to where you want him to be spawned and enable his logic. That is a less scaleable and more simplistic form of an Object Pool using just an array.\nSo how did I go about making my object pooler? First I created a new script in Unity duuh and started by making the script a singleton. Several other scripts will need access to the object pool during gameplay and the singleton allows other scripts to access it without getting a Component from a GameObject.\n1 2 3 4  public static ObjectPooler Instance; void Awake() { Instance = this; }   Next I add using System.Collection.Generic. I will be using a generic list to store my pooled objects. Typically, you use generics when working with collections. This approach allows you to have an array that only allows one type of object, preventing you from putting a dog inside a cat array.\nThen I add create the Object pool List along with 2 new variables. You can also make them private and Serialize the fields so that you can access them in the Unity Inspector.\n1 2 3  public List\u0026lt;GameObject\u0026gt; pooledObjects; public int amountToPool; public GameObject objectToPool;   After we have the List and variables setup it\u0026rsquo;s time to instantiate the GameObject objectToPool. I do that in the Start()function with a for loop based on the number of times in the int amountToPool variable I created earlier. Then I set the GameObjects to inactive before adding them to the pooledObjects list.\n1 2 3 4 5 6 7 8  pooledObjects = new List\u0026lt;GameObject\u0026gt;(); for (int i = 0; i \u0026lt; item.amountToPool; i++) { GameObject obj = (GameObject)Instantiate(item.objectToPool); obj.SetActive(false); pooledObjects.Add(obj); }   At this point when you run the game in the hierarchy you will see all of the pooled objects based on the amount you specified in the Inspector.\nNext we want to be able to get an object from the object pool.\n1 2 3 4 5 6 7 8 9  public GameObject GetPooledObject() { for (int i = 0; i \u0026lt; pooledObjects.Count; i++) { if (!pooledObjects[i].activeInHierarchy) { return pooledObjects[i]; } } return null; }   It is important to note that the GetPooledObject()function has a return type of GameObject. First we iterate throught the pooledObjects list, then check to see if the item in the list is not currently active in the Scene. If it is, the loop moves to the next object in the list. If not, then exit the function and give the inactive object to the function that called GetPooledObject(). Now that I have a way to get an item from the object pool I need to replace all of the Instantiate() and Destroy() code so that we can start using it.\nI instantiate my bullets in the Player class using a Fire() function. The function is called during Update() when the Mouse Button is held down.\nThe important thing to notice is that I ask the Fire() function to ask the ObjectPooler for a pooled object. If one is available, it\u0026rsquo;s set to the desired position and then set to active.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private void Fire() { Vector2 direction = mousePos - myRigidBody.position; direction.Normalize(); GameObject bullet = ObjectPooler.Instance.GetPooledObjects(\u0026#34;PlayerBullet\u0026#34;); if (bullet != null) { bullet.transform.position = bulletFirePos.position; bullet.SetActive(true); } else { return; } Rigidbody2D bulletBody = bullet.GetComponent\u0026lt;Rigidbody2D\u0026gt;(); bulletBody.rotation = GetZAngle(0); bulletBody.velocity = direction * bulletSpeed; }   Next step is to handle and replace the Destroy() functionality of the bullets. The way I\u0026rsquo;ve handled that is quite simple. I have setup 4 colliders around my screen which are also Triggers. When a bullet intersects with a collider the OnTriggerEnter2D() function is called and I set the bullet to inactive. Doing the same thing if the bullet and an enemy collide as well.\n1 2 3 4 5 6 7 8 9 10 11  void OnTriggerEnter2D(Collider2D other) { bool isShredder = other.CompareTag(\u0026#34;Shredder\u0026#34;); if (isShredder) { gameObject.SetActive(false); } bool isEnemy = other.CompareTag(\u0026#34;EnemyEasy\u0026#34;); if (isEnemy) { gameObject.SetActive(false); } }   Now when I hit play all the hard work pays off and the object pooler works wonderfully. All that is left is to figure out how big we want the List to be. If I\u0026rsquo;m ever going to have 10 bullets on screen at the same time, it would be pointless to have the list instantiate 100 bullets.\nOf course that raises the question. What happens if we somehow end up with 11 bullets when the List only supports 10? Luckily it is quite easy to add the functionality to expand our List.\nFirst create a new public bool shouldExpand = true;. That will add a checkbox in the Inspector where we can indicate whether or not we want the List to be able to expand.\nNext in the GetPooledObjects() just replace the return null; with:\n1 2 3 4 5 6 7 8  if (shouldExpand) { GameObject obj = (GameObject)Instantiate(objectToPool); obj.SetActive(false); pooledObjects.Add(obj); return obj; } else { return null; }   If a new bullet is requested from the pool but no inactive ones can be found, this if statement checks to see if it\u0026rsquo;s possible to expand the pool instead of exiting the function. If it is, a new bullet is instantiated and added to the pool, also sets it to inactive and is returned to the function that called GetPooledObjects().\nNow we finally have a simple and fully working Object Pooler. There is plenty of ways I could expand it in the future. Such as adding the functionality to have multiple lists for enemies, explosions, powerups etc. For now this works perfectly for my small project. Hope you enjoyed reading through this blog post and learned something new.\nSee you again in the next post! ","description":"How I implemented Object Pooling in a side project in Unity","id":1,"section":"posts","tags":["unity","mechanic","c_sharp"],"title":"Object Pooling - Deep Dive","uri":"https://devpilgrim.com/posts/objectpooling/"},{"content":"This was the very first game I made when I got into University. It was made as a project for the CMP105 Games Course (Link for the module description below).\nThe game was made utilizing the SFML Library and C++.\nAs my very first game I learned quite a bit, and I also messed up quite a lot. It was a good introduction into the of games programming which is also what sparked my interest to continue learning and wanting to get better at it.\nEvery project is a stepping stone onto and this project was my first step into the world of game programming.\n","description":"First Game I ever made","id":2,"section":"posts","tags":["sfml","cpp"],"title":"Asteroids","uri":"https://devpilgrim.com/posts/asteroids/"},{"content":"With this course we got introduced to OpenGL, or more specifically GLUT. The goal of this course and project was to design and develop a 3D graphics application and scene that exhibits key techniques in graphics programming using OpenGL.\nThe techniques I have successfuly implemented are:\nLighting  Point light and a spot light different properties on the geometry to simulate different reflection values and materials  Geometry  hand crafted geometry using vertexes transparent textures depth buffer for the skybox hierarchy modelling for planets orbiting a sun trilinear filtering for the ground texture  Camera  fully functioning 1st person camera with keyboard and mouse movement static birds eye camera\n  This was an amazing learning experience. I had not used an API before and it was interesting to learn how the render pipeline works. The biggest challenge I faced in this project was the calculations for the camera, but with the help of the teaching staff and fellow students I got it working as I wanted and understood much better how the math behind it works.\n","description":"First experience using OpenGL and the Render Pipeline","id":3,"section":"posts","tags":["opengl","cpp"],"title":"OpenGL Scene","uri":"https://devpilgrim.com/posts/opengl/"},{"content":"Year 2 we started learning about different kinds of data structures and algorithms as well as applying them.\nFor the assessment project we had to create an application which implements two different standard algorithms with the appropriate data structures and the ability to vary the size of the input data.\nI chose two different string searching algorithms. The Rabin Karp algorithm which is utilizes a brute force process and the Boyer Moore algorithm, which utilizes a skipping approach to string searching.\nThe performance of the algorithms was compared using the following inputs in an abstract from the book \u0026ldquo;Lord of the Rings\u0026rdquo;:\n most common english words most common english letter least common english letter string that is not contained in the text string at the end of the document very long string that is contained in the text\n  Testing with both algoritms I came to the conclusion that the Boyer Moore algorithm excels when it has to skip more in between found strings. When both algorithms are searching for a common string inside the text, the performance difference is close between both algorithms. If you are searching for something more “rare” or less likely to be contained in the text, then use Boyer Moore.\n","description":"Comparing Boyer-Moore vs Rabin Karp","id":4,"section":"posts","tags":["algorithms","cpp"],"title":"String Searching - Data Structures and Algorithms","uri":"https://devpilgrim.com/posts/string_searching/"},{"content":"This was my last project for Year 2. Purpose of the project is to demonstrate knowledge and proficiency by using and manipulating textured 3D geometry, multiple interactable game states and physics interactions using the Box2D library (3D objects on a 2D plane) and the GEF framework.\nGameplay wise you have a player ship and respawnable enemies. The goal is to survive for as long as possible while getting the highest score you can. There are collision based physics interactions between the player, enemies, bullets and ground. A spin I added is that you can manipulate the bullets while they are flying. You as the player decide in which direction they fly and it can be changes mid air.\nThe biggest thing I learned from this project was how to make my own class based State Machine. Apart from the state machine was interesting to use the Box2D library for the first time and not have to write my own collision.\n","description":"My first experience with Box2D and my last project for Year 2","id":5,"section":"posts","tags":["gef","box2d","cpp"],"title":"2.5D Game using Box2D and the GEF Framework","uri":"https://devpilgrim.com/posts/gef_and_box2d/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":6,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://devpilgrim.com/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":7,"section":"gallery","tags":null,"title":"Photo","uri":"https://devpilgrim.com/gallery/photo/"},{"content":"My name is Hristo and I am a final year Computer Games Application Development student at Abertay University. In this website you can find a combination of my Portfolio as well as blog posts I write. \rSince a very young age I have been playing video games. The more I played the more interested I became in how they are made and wanted to learn how to make them. This is reason why after graduation High School I enrolled into Abertay University to study Computer Game Application Development. The more I study about games and how they are made the more passionate I become about it. It is my dream job and am constantly working on new side projects to further my skills and knowledge in the industry.\n","description":"Description","id":9,"section":"","tags":null,"title":"About","uri":"https://devpilgrim.com/about/"}]